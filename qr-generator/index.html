<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>QR Code (Optional Logo) Generator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
  <style>
    :root{
      --qr-size: 512px;         /* Final QR side length */
      --logo-max-ratio: 0.28;   /* Max logo width relative to QR (<= 0.30 recommended) */
    }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; padding: 24px; }
    h1 { font-size: 20px; margin-bottom: 12px; }
    .card { max-width: 880px; margin: 0 auto; padding: 16px; border: 1px solid #e5e7eb; border-radius: 14px; box-shadow: 0 10px 16px rgba(0,0,0,0.04); }
    .grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap: 14px; }
    label { font-size: 14px; color: #374151; display: block; margin-bottom: 6px; }
    input[type="text"], select { width: 100%; padding: 10px 12px; border: 1px solid #d1d5db; border-radius: 10px; font-size: 14px; }
    input[type="file"] { width: 100%; }
    input[type="color"] { height: 40px; width: 100%; padding: 0; border: 1px solid #d1d5db; border-radius: 10px; }
    .row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; }
    .actions { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; }
    button {
      padding: 10px 14px; border: 0; border-radius: 10px;
      background: #111827; color: white; font-weight: 600; cursor: pointer;
    }
    button.secondary { background: #f3f4f6; color: #111827; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .muted { color: #6b7280; font-size: 13px; }
    .error { color: #b91c1c; background: #fee2e2; border: 1px solid #fecaca; padding: 8px 10px; border-radius: 8px; font-size: 13px; }
    .ok { color: #065f46; background: #d1fae5; border: 1px solid #a7f3d0; padding: 8px 10px; border-radius: 8px; font-size: 13px; }

    /* Output area */
    .output { 
    margin-top: 18px; 
    display: grid; 
    justify-items: center; 
    }

    /* Make the QR responsive on small screens */
    #compositeCanvas {
    display: none;
    width: 90vw;        /* fill most of the viewport width on mobile */
    height: auto;       /* keep aspect ratio */
    max-width: 512px;   /* cap on larger screens */
    /*image-rendering: pixelated;*/
    border: 1px dashed #e5e7eb;
    border-radius: 10px;
    }


    /* optional: prevent any horizontal scroll */
    body { overflow-x: hidden; }

    /* Hidden internal QR render target */
    #qrcode { display: none; }
    /* 1) Saner sizing so 100% width inputs don't overflow */
    *, *::before, *::after { box-sizing: border-box; }

    /* 2) Let grid items shrink within their column */
    .grid > * { min-width: 0; }

    /* (optional) keep items from stretching weirdly */
    .grid { align-items: start; }

    /* (optional) ensure form controls never exceed their cell */
    input[type="text"], input[type="file"], select { max-width: 100%; }

    /* current: repeat(auto-fit, minmax(260px, 1fr)) */
    /* try a larger minimum */
    .grid { grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); }

    /* or force single column below a width */
    @media (max-width: 720px) {
    .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>QR Code Generator</h1>

    <div class="grid">
      <div>
        <label for="urlInput">Target URL</label>
        <input id="urlInput" type="text" placeholder="https://www.your-website.com"
               value="https://www.your-website.com" />
        <div class="muted">Enter the exact URL to encode in the QR.</div>
      </div>

      <div>
        <label for="logoInput">Upload Logo (optional)</label>
        <input id="logoInput" type="file" accept="image/*" />
        <div class="muted">PNG with transparent background recommended. Max 2 MB. 64–1024 px.</div>
      </div>

      <div>
        <label>Background</label>
        <div class="row">
          <label class="row" style="gap:6px; align-items:center;">
            <input id="bgTransparent" type="checkbox" selected/>
            <span>Transparent</span>
          </label>
          <input id="bgColor" type="color" value="#ffffff" title="Background color" />
        </div>
        <div class="muted">If transparent is checked, color is ignored.</div>
      </div>

      <div>
        <label for="clipStyle">Logo Shape</label>
        <select id="clipStyle">
          <option value="none">None</option>
          <option value="rounded">Rounded Square</option>
          <option value="circle">Circle</option>
        </select>
        <div class="row" id="radiusRow" style="margin-top:8px;">
          <input id="cornerRadius" type="range" min="4" max="64" value="16" />
          <span class="muted" id="cornerRadiusLabel">Corner radius: 16 px</span>
        </div>
        <div class="muted">Clipping only applies if a logo is uploaded.</div>
      </div>
    </div>

    <div class="actions" style="margin-top:12px;">
      <button id="generateBtn">Generate QR</button>
      <button id="downloadBtn" class="secondary" disabled>Download PNG</button>
      <button id="clearBtn" class="secondary" disabled>Clear</button>
    </div>

    <div id="messages" style="margin-top:10px;"></div>

    <!-- Hidden base render target (QRCode.js injects canvas/img here) -->
    <div id="qrcode"></div>

    <!-- Final output canvas (only visible after generation) -->
    <div class="output">
      <canvas id="compositeCanvas" width="512" height="512"></canvas>
    </div>
  </div>

  <script>
    // ====== Tweakable constraints ======
    //const QR_SIZE = 512;             // final output size in px (canvas size)
    const LOGO_MAX_RATIO = 0.28;     // logo width/max relative to QR width (<= 0.30 recommended)
    const LOGO_MIN_PX = 64;          // min allowed logo width & height in pixels
    const LOGO_MAX_PX = 1024;        // max allowed logo width & height in pixels
    const FILE_SIZE_MAX = 2 * 1024 * 1024; // 2 MB

    // ====== Elements ======
    const urlInput = document.getElementById('urlInput');
    const logoInput = document.getElementById('logoInput');
    const bgTransparent = document.getElementById('bgTransparent');
    const bgColor = document.getElementById('bgColor');
    const clipStyle = document.getElementById('clipStyle');
    const cornerRadius = document.getElementById('cornerRadius');
    const cornerRadiusLabel = document.getElementById('cornerRadiusLabel');
    const radiusRow = document.getElementById('radiusRow');

    const generateBtn = document.getElementById('generateBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const clearBtn = document.getElementById('clearBtn');

    const messages = document.getElementById('messages');
    const qrcodeContainer = document.getElementById('qrcode');      // hidden QR render target
    const compositeCanvas = document.getElementById('compositeCanvas'); // final export (hidden until generated)
    const compositeCtx = compositeCanvas.getContext('2d');

    let logoImage = null;       // HTMLImageElement after load
    let logoMeta = null;        // {width, height, sizeBytes, type}
    let qrInstance = null;

    function getDynamicQRSize() {
    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
    // 90% of viewport width, clamped between 256 and 512
    return Math.min(Math.max(Math.floor(vw * 0.9), 256), 512);
    }

    function getCanvasSizes() {
        const css = getDynamicQRSize();              // e.g. 320 CSS px on a phone
        const dpr = Math.max(1, window.devicePixelRatio || 1); // e.g. 3 on many phones
        const px  = Math.ceil(css * dpr);            // device pixels for sharp export
        return { css, px, dpr };
    }

    // UI display logic
    function updateRadiusVisibility() {
      radiusRow.style.display = (clipStyle.value === 'rounded') ? 'flex' : 'none';
    }
    clipStyle.addEventListener('change', updateRadiusVisibility);
    updateRadiusVisibility();

    cornerRadius.addEventListener('input', () => {
      cornerRadiusLabel.textContent = `Corner radius: ${cornerRadius.value} px`;
    });

    bgTransparent.addEventListener('change', () => {
      bgColor.disabled = bgTransparent.checked;
    });
    bgColor.disabled = bgTransparent.checked;

    function updateBgColorVisibility() {
    const hidden = bgTransparent.checked;
    bgColor.style.display = hidden ? 'none' : '';
    bgColor.disabled = hidden;
    }

    updateBgColorVisibility();
    bgTransparent.addEventListener('change', updateBgColorVisibility);
    
    // Messaging helpers
    function showMessage(html, type='ok') {
      messages.innerHTML = `<div class="${type}">${html}</div>`;
    }
    function clearMessage() { messages.innerHTML = ''; }

    // Validation
    function validateLogoFile(file) {
      if (!file) return { ok: false, reason: 'No file selected.' };

      const typeOk = file.type.startsWith('image/');
      if (!typeOk) {
        return { ok: false, reason: `Unsupported file type: ${file.type || 'unknown'}. Please upload an image.` };
      }

      if (file.size > FILE_SIZE_MAX) {
        return { ok: false, reason: `File too large (${(file.size/1024/1024).toFixed(2)} MB). Max allowed is ${(FILE_SIZE_MAX/1024/1024)} MB.` };
      }

      return { ok: true };
    }

    // Load image
    function loadImageFromFile(file) {
      return new Promise((resolve, reject) => {
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { URL.revokeObjectURL(url); resolve(img); };
        img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Failed to load image.')); };
        img.src = url;
      });
    }

    async function onLogoSelected() {
      clearMessage();
      const file = logoInput.files?.[0];
      if (!file) {
        logoImage = null; logoMeta = null;
        showMessage('No logo selected. You can generate the QR without a logo.', 'ok');
        return;
      }

      const basic = validateLogoFile(file);
      if (!basic.ok) {
        showMessage(basic.reason, 'error');
        logoImage = null; logoMeta = null;
        return;
      }

      try {
        const img = await loadImageFromFile(file);
        const w = img.naturalWidth;
        const h = img.naturalHeight;

        if (w < LOGO_MIN_PX || h < LOGO_MIN_PX) {
          showMessage(`Logo is too small (${w}×${h}). Minimum is ${LOGO_MIN_PX}×${LOGO_MIN_PX}px.`, 'error');
          logoImage = null; logoMeta = null; return;
        }
        if (w > LOGO_MAX_PX || h > LOGO_MAX_PX) {
          showMessage(`Logo is too large (${w}×${h}). Maximum is ${LOGO_MAX_PX}×${LOGO_MAX_PX}px. Please resize and upload again.`, 'error');
          logoImage = null; logoMeta = null; return;
        }

        logoImage = img;
        logoMeta = { width: w, height: h, sizeBytes: file.size, type: file.type };
        showMessage(`Logo OK: ${w}×${h}px, ${(file.size/1024).toFixed(0)} KB, ${file.type}.`, 'ok');
      } catch (err) {
        showMessage(`Could not read image: ${err.message}`, 'error');
        logoImage = null; logoMeta = null;
      }
    }
    logoInput.addEventListener('change', onLogoSelected);

    // Generate QR (nothing is displayed until user clicks)
    /*function generateQR() {
      clearMessage();
      clearQRBase(); // ensure a clean start

      const url = urlInput.value.trim();
      if (!url) {
        showMessage('Please enter a valid URL.', 'error');
        return;
      }

      // Internal, larger render for crisp scaling
      const INTERNAL_QR_SIZE = 1024;
      const lightColor = bgTransparent.checked ? 'rgba(255,255,255,0)' : bgColor.value;

      qrInstance = new QRCode(qrcodeContainer, {
        text: url,
        width: INTERNAL_QR_SIZE,
        height: INTERNAL_QR_SIZE,
        colorDark: "#000000",
        colorLight: lightColor,
        correctLevel: QRCode.CorrectLevel.H
      });

      // Wait a tick for QRCode.js to inject the canvas/img
      requestAnimationFrame(() => {
        let qrEl = qrcodeContainer.querySelector('canvas') || qrcodeContainer.querySelector('img');
        if (!qrEl) {
          showMessage('Failed to render QR. Please try again.', 'error');
          return;
        }

        drawComposite(qrEl, logoImage, {
          bgTransparent: bgTransparent.checked,
          bgColor: bgColor.value,
          clip: clipStyle.value,
          cornerRadius: parseInt(cornerRadius.value, 10) || 16
        });

        // Show output + enable actions
        compositeCanvas.style.display = 'block';
        downloadBtn.disabled = false;
        clearBtn.disabled = false;

        if (!logoImage) {
          showMessage('QR generated without a logo (no logo uploaded).', 'ok');
        }
      });
    }*/
/*
    function generateQR() {
    clearMessage();
    clearQRBase();

    const url = urlInput.value.trim();
    if (!url) { showMessage('Please enter a valid URL.', 'error'); return; }

    const INTERNAL_QR_SIZE = 1024; // keep this high for crisp downscaling
    const lightColor = bgTransparent.checked ? 'rgba(255,255,255,0)' : bgColor.value;

    // render QR base into hidden container
    new QRCode(qrcodeContainer, {
        text: url,
        width: INTERNAL_QR_SIZE,
        height: INTERNAL_QR_SIZE,
        colorDark: "#000000",
        colorLight: lightColor,
        correctLevel: QRCode.CorrectLevel.H
    });

    requestAnimationFrame(() => {
        const qrEl = qrcodeContainer.querySelector('canvas') || qrcodeContainer.querySelector('img');
        if (!qrEl) { showMessage('Failed to render QR. Please try again.', 'error'); return; }

        // compute dynamic size RIGHT BEFORE drawing
        const qrSize = getDynamicQRSize();
        drawComposite(qrEl, logoImage, {
        size: qrSize,
        bgTransparent: bgTransparent.checked,
        bgColor: bgColor.value,
        clip: clipStyle.value,
        cornerRadius: parseInt(cornerRadius.value, 10) || 16
        });

        compositeCanvas.style.display = 'block';
        downloadBtn.disabled = false;
        clearBtn.disabled = false;
        if (!logoImage) showMessage('QR generated without a logo (no logo uploaded).', 'ok');
    });
    }
*/
    function generateQR() {
        clearMessage();
        clearQRBase();

        const url = urlInput.value.trim();
        if (!url) { showMessage('Please enter a valid URL.', 'error'); return; }

        const { css, px, dpr } = getCanvasSizes();

        // Make the hidden QR as large as the device-pixel canvas (or >=1024 for crisp downscaling)
        const INTERNAL_QR_SIZE = Math.max(1024, px);
        const lightColor = bgTransparent.checked ? 'rgba(255,255,255,0)' : bgColor.value;

        new QRCode(qrcodeContainer, {
            text: url,
            width:  INTERNAL_QR_SIZE,
            height: INTERNAL_QR_SIZE,
            colorDark: "#000000",
            colorLight: lightColor,
            correctLevel: QRCode.CorrectLevel.H
        });

        requestAnimationFrame(() => {
            const qrEl = qrcodeContainer.querySelector('canvas') || qrcodeContainer.querySelector('img');
            if (!qrEl) { showMessage('Failed to render QR. Please try again.', 'error'); return; }

            drawComposite(qrEl, logoImage, {
            cssSize: css,
            pixelSize: px,
            dpr,
            bgTransparent: bgTransparent.checked,
            bgColor: bgColor.value,
            clip: clipStyle.value,
            cornerRadius: parseInt(cornerRadius.value, 10) || 16
            });

            compositeCanvas.style.display = 'block';
            downloadBtn.disabled = false;
            clearBtn.disabled = false;
            if (!logoImage) showMessage('QR generated without a logo (no logo uploaded).', 'ok');
        });
    }


/*
    function drawComposite(qrSource, logoImg, opts) {
      const { bgTransparent, bgColor, clip, cornerRadius } = opts;

      compositeCanvas.width = QR_SIZE;
      compositeCanvas.height = QR_SIZE;

      // Background
      compositeCtx.clearRect(0, 0, QR_SIZE, QR_SIZE);
      if (!bgTransparent) {
        compositeCtx.fillStyle = bgColor || '#ffffff';
        compositeCtx.fillRect(0, 0, QR_SIZE, QR_SIZE);
      }

      // Draw QR scaled to target size
      compositeCtx.drawImage(qrSource, 0, 0, QR_SIZE, QR_SIZE);

      // If no logo, done
      if (!logoImg) return;

      // Compute logo placement
      const maxLogoW = QR_SIZE * LOGO_MAX_RATIO;
      const maxLogoH = QR_SIZE * LOGO_MAX_RATIO;

      const lw = logoImg.naturalWidth;
      const lh = logoImg.naturalHeight;
      const logoScale = Math.min(maxLogoW / lw, maxLogoH / lh, 1);
      const drawW = Math.round(lw * logoScale);
      const drawH = Math.round(lh * logoScale);
      const dx = Math.round((QR_SIZE - drawW) / 2);
      const dy = Math.round((QR_SIZE - drawH) / 2);

      const pad = 6; // contrast pad behind logo

      compositeCtx.save();

      if (clip === 'circle') {
        // white circular pad
        compositeCtx.beginPath();
        compositeCtx.arc(dx + drawW/2, dy + drawH/2, Math.max(drawW, drawH)/2 + pad, 0, Math.PI * 2);
        compositeCtx.fillStyle = '#ffffff';
        compositeCtx.fill();

        // circle clip for the logo
        compositeCtx.beginPath();
        compositeCtx.arc(dx + drawW/2, dy + drawH/2, Math.min(drawW, drawH)/2, 0, Math.PI * 2);
        compositeCtx.clip();
      } else if (clip === 'rounded') {
        // white rounded rect pad
        roundRect(compositeCtx, dx - pad, dy - pad, drawW + pad * 2, drawH + pad * 2, cornerRadius);
        compositeCtx.fillStyle = '#ffffff';
        compositeCtx.fill();

        // rounded rect clip for the logo
        roundRect(compositeCtx, dx, dy, drawW, drawH, cornerRadius);
        compositeCtx.clip();
      } else {
        // plain white small-rounded pad for visibility without clipping
        roundRect(compositeCtx, dx - pad, dy - pad, drawW + pad * 2, drawH + pad * 2, Math.min(16, Math.round(Math.min(drawW, drawH) * 0.2)));
        compositeCtx.fillStyle = '#ffffff';
        compositeCtx.fill();
      }

      // Draw the logo
      compositeCtx.drawImage(logoImg, dx, dy, drawW, drawH);
      compositeCtx.restore();
    }
*/
/*
    function drawComposite(qrSource, logoImg, opts) {
    const { size, bgTransparent, bgColor, clip, cornerRadius } = opts;
    const LOGO_MAX_RATIO = 0.28;

    // set canvas pixel size to the dynamic size
    compositeCanvas.width = size;
    compositeCanvas.height = size;

    const ctx = compositeCanvas.getContext('2d');
    ctx.clearRect(0, 0, size, size);

    if (!bgTransparent) {
        ctx.fillStyle = bgColor || '#ffffff';
        ctx.fillRect(0, 0, size, size);
    }

    // draw QR scaled into the target square
    ctx.drawImage(qrSource, 0, 0, size, size);

    // stop if no logo
    if (!logoImg) return;

    // compute logo placement
    const maxLogoW = size * LOGO_MAX_RATIO;
    const maxLogoH = size * LOGO_MAX_RATIO;
    const lw = logoImg.naturalWidth, lh = logoImg.naturalHeight;
    const scale = Math.min(maxLogoW / lw, maxLogoH / lh, 1);
    const drawW = Math.round(lw * scale);
    const drawH = Math.round(lh * scale);
    const dx = Math.round((size - drawW) / 2);
    const dy = Math.round((size - drawH) / 2);

    const pad = 6;
    ctx.save();
    if (clip === 'circle') {
        ctx.beginPath();
        ctx.arc(dx + drawW/2, dy + drawH/2, Math.max(drawW, drawH)/2 + pad, 0, Math.PI * 2);
        ctx.fillStyle = '#ffffff';
        ctx.fill();

        ctx.beginPath();
        ctx.arc(dx + drawW/2, dy + drawH/2, Math.min(drawW, drawH)/2, 0, Math.PI * 2);
        ctx.clip();
    } else if (clip === 'rounded') {
        roundRect(ctx, dx - pad, dy - pad, drawW + pad*2, drawH + pad*2, cornerRadius);
        ctx.fillStyle = '#ffffff';
        ctx.fill();

        roundRect(ctx, dx, dy, drawW, drawH, cornerRadius);
        ctx.clip();
    } else {
        roundRect(ctx, dx - pad, dy - pad, drawW + pad*2, drawH + pad*2, Math.min(16, Math.round(Math.min(drawW, drawH)*0.2)));
        ctx.fillStyle = '#ffffff';
        ctx.fill();
    }

    ctx.drawImage(logoImg, dx, dy, drawW, drawH);
    ctx.restore();
    }
*/

    function drawComposite(qrSource, logoImg, opts) {
        const { cssSize, pixelSize, dpr, bgTransparent, bgColor, clip, cornerRadius } = opts;
        const LOGO_MAX_RATIO = 0.28;

        // Set the canvas backing resolution to device pixels,
        // but display it at the CSS size.
        compositeCanvas.width = pixelSize;
        compositeCanvas.height = pixelSize;
        compositeCanvas.style.width = cssSize + 'px';
        compositeCanvas.style.height = cssSize + 'px';

        const ctx = compositeCanvas.getContext('2d');

        // Reset transform, clear in device pixels, then draw in CSS coords via scale
        ctx.setTransform(1,0,0,1,0,0);
        ctx.clearRect(0, 0, pixelSize, pixelSize);
        ctx.scale(dpr, dpr); // from now on, all coords are in CSS pixels

        // Background (CSS coords)
        if (!bgTransparent) {
            ctx.fillStyle = bgColor || '#ffffff';
            ctx.fillRect(0, 0, cssSize, cssSize);
        }

        // Draw QR (disable smoothing so modules stay crisp)
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(qrSource, 0, 0, cssSize, cssSize);

        // If no logo, done
        if (!logoImg) return;

        // Compute logo size/position in CSS pixels
        const maxLogoW = cssSize * LOGO_MAX_RATIO;
        const maxLogoH = cssSize * LOGO_MAX_RATIO;
        const lw = logoImg.naturalWidth, lh = logoImg.naturalHeight;
        const scale = Math.min(maxLogoW / lw, maxLogoH / lh, 1);
        const drawW = Math.round(lw * scale);
        const drawH = Math.round(lh * scale);
        const dx = Math.round((cssSize - drawW) / 2);
        const dy = Math.round((cssSize - drawH) / 2);

        const pad = 6;

        ctx.save();

        // Contrast pad + optional clipping
        if (clip === 'circle') {
            ctx.beginPath();
            ctx.arc(dx + drawW/2, dy + drawH/2, Math.max(drawW, drawH)/2 + pad, 0, Math.PI * 2);
            ctx.fillStyle = '#ffffff';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(dx + drawW/2, dy + drawH/2, Math.min(drawW, drawH)/2, 0, Math.PI * 2);
            ctx.clip();
        } else if (clip === 'rounded') {
            roundRect(ctx, dx - pad, dy - pad, drawW + pad*2, drawH + pad*2, cornerRadius);
            ctx.fillStyle = '#ffffff';
            ctx.fill();

            roundRect(ctx, dx, dy, drawW, drawH, cornerRadius);
            ctx.clip();
        } else {
            roundRect(ctx, dx - pad, dy - pad, drawW + pad*2, drawH + pad*2, Math.min(16, Math.round(Math.min(drawW, drawH) * 0.2)));
            ctx.fillStyle = '#ffffff';
            ctx.fill();
        }

        // Enable smoothing for the logo (photos/graphics look better)
        ctx.imageSmoothingEnabled = true;
        ctx.drawImage(logoImg, dx, dy, drawW, drawH);
        ctx.restore();
    }

    function roundRect(ctx, x, y, w, h, r) {
    const m = Math.min(w, h);
    if (r > m/2) r = m/2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    }


    function roundRect(ctx, x, y, w, h, r) {
    const m = Math.min(w, h);
    if (r > m/2) r = m/2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    }


    function roundRect(ctx, x, y, w, h, r) {
      const min = Math.min(w, h);
      if (r > min / 2) r = min / 2;
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function downloadPNG() {
      const link = document.createElement('a');
      link.download = 'qr-with-logo.png';
      link.href = compositeCanvas.toDataURL('image/png');
      link.click();
    }

    function clearQRBase() {
      qrcodeContainer.innerHTML = '';
    }

    function clearOutput() {
      clearMessage();
      clearQRBase();
      compositeCtx.clearRect(0, 0, compositeCanvas.width, compositeCanvas.height);
      compositeCanvas.style.display = 'none';
      downloadBtn.disabled = true;
      clearBtn.disabled = true;
    }

    // Events
    generateBtn.addEventListener('click', generateQR);
    downloadBtn.addEventListener('click', downloadPNG);
    clearBtn.addEventListener('click', clearOutput);

    bgColor.addEventListener('input', () => {
    if (!bgTransparent.checked) generateQR();
    });
    //bgTransparent.addEventListener('change', () => generateQR());


  </script>
</body>
</html>
